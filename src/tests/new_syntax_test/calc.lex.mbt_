fn parse_integer(input : @bytes.View) -> Int {
  loop 0, input {
    acc, [] => acc
    acc, ['0'..='9' as c, .. rest] =>
      continue acc * 10 + (c.to_int() - '0'), rest
    _, _ => panic()
  }
}

fn eval(input : Bytes) -> Int {
  const DIGIT : BytesRegex = "[0-9]"
  const NUMBER : BytesRegex = "\{DIGIT}+"

  let lexbuf = BytesLexbuf::from_bytes(input)
  let stack : Array[Int] = []
  for {
    lex lexbuf {
      "$" => { break }
      " " => { continue }
      NUMBER as t => { stack.push(parse_integer(t)) }
      "\\+" => {
        let arg2 = stack.unsafe_pop()
        let arg1 = stack.unsafe_pop()
        stack.push(arg1 + arg2)
      }
      "-" => {
        let arg2 = stack.unsafe_pop()
        let arg1 = stack.unsafe_pop()
        stack.push(arg1 - arg2)
      }
    }
  }
  stack.unsafe_pop()
}
