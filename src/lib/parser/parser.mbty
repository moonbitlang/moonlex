%start lex_eoi
%start regex_eoi
%position<Int>
%derive<Show> Token
%derive<Show> ParseError

%token EOI
%token EOF          "eof"
%token PARSE_LBRACE "parse {"
%token REGEX        "regex"
%token AS           "as"
%token UNDERSCORE   "_"
%token RBRACE       "}"
%token LPAREN       "("
%token RPAREN       ")"
%token LBRACKET     "["
%token RBRACKET     "]"
%token EQ           "="
%token COLON        ":"
%token SEMICOLON    ";"
%token FAT_ARROW    "=>"
%token BAR          "|"
%token STAR         "*"
%token PLUS         "+"
%token QUESTION     "?"
%token MINUS        "-"
%token CARET        "^"
%token BACKSLASH // "\\"

%token<(String, String)> RULE_LC_IDENT_LPAREN_CODE_RPAREN_ARROW_CODE_LBRACE
%token<String> LBRACE_CODE_RBRACE
%token<String> LC_IDENT
%token<Char> CHAR
%token<String> STRING

%%

lex_eoi                                 -> (Context) -> @type.Lex
  : lex EOI                             { $1 }
  ;

regex_eoi                               -> (Context) -> @type.Regex
  : regex EOI                           { $1 }
  ;

lex                                     -> (Context) -> @type.Lex
  :                                     { fn { _ctx => { header: "", rules: [],  trailer: "" } } }
  | header named_regex_list nonempty_rule_list trailer 
                                        {
                                          fn (ctx) {
                                            let ctx = $2(ctx)
                                            { header: $1, rules: $3(ctx).to_array(), trailer: $4 }
                                          } 
                                        }
  ;

header                                  -> String
  : LBRACE_CODE_RBRACE                  { $1 }
  |                                     { "" }
  ;

trailer                                 -> String 
  : LBRACE_CODE_RBRACE                  { $1 }
  |                                     { "" }
  ;

named_regex_list                        -> (Context) -> Context
  : named_regex named_regex_list        { fn { ctx => $2($1(ctx)) } }
  |                                     { fn { ctx => ctx } }
  ;

named_regex                             -> (Context) -> Context
  : "regex" LC_IDENT "=" regex ";"      { fn { ctx => ctx.define_regex($2, $4(ctx)) } }
  ;

nonempty_rule_list                      -> (Context) -> @immut/list.T[@type.Rule]
  : rule                                { fn { ctx => Cons($1(ctx), Nil) } }
  | rule nonempty_rule_list             { fn { ctx => Cons($1(ctx), $2(ctx)) } }
  ;

rule                                    -> (Context) -> @type.Rule
  : RULE_LC_IDENT_LPAREN_CODE_RPAREN_ARROW_CODE_LBRACE "parse {" rule_item_list "}" "}" 
                                        { fn { ctx => { name: $1.0, signature: $1.1, patterns: $3(ctx).to_array() } } }
  ;

rule_item_list                          -> (Context) -> @immut/list.T[(@type.Regex, @type.CodeBlock)]
  : rule_item rule_item_list            { fn { ctx => Cons($1(ctx), $2(ctx)) } }
  |                                     { fn { _ctx => Nil } }
  ;

rule_item                               -> (Context) -> (@type.Regex, @type.CodeBlock)
  : regex "=>" LBRACE_CODE_RBRACE       { fn { ctx => ($1(ctx), $3) } }
  ;

regex                                   -> (Context) -> @type.Regex
  : alias                               { $1 }
  ;

alias                                   -> (Context) -> @type.Regex
  : alternation                         { $1 }
  | alternation "as" LC_IDENT           { fn { ctx => @regex.bind($1(ctx), $3) } }
  ;

alternation                             -> (Context) -> @type.Regex
  : concatenation                       { $1 }
  | concatenation "|" alternation       { fn { ctx => @regex.alt($1(ctx), $3(ctx)) } }
  ;

concatenation                           -> (Context) -> @type.Regex
  : repetition                          { $1 }
  | repetition concatenation            { fn { ctx => @regex.seq($1(ctx), $2(ctx)) } }
  | differentiation                     { $1 }
  ;

differentiation                         -> (Context) -> @type.Regex
  : atom BACKSLASH atom                 {
                                          fn (ctx) {
                                            guard $1(ctx) is Character(cset1) && $3(ctx) is Character(cset2)
                                            @regex.char_class(cset1.difference(cset2))
                                          }
                                        }
  | differentiation BACKSLASH atom      {
                                          fn (ctx) {
                                            guard $1(ctx) is Character(cset1) && $3(ctx) is Character(cset2)
                                            @regex.char_class(cset1.difference(cset2))
                                          }
                                        }
  ;

repetition                              -> (Context) -> @type.Regex
  : atom                                { $1 }
  | atom "*"                            { fn { ctx => @regex.star($1(ctx)) } }
  | atom "+"                            { fn { ctx => @regex.plus($1(ctx)) } }
  | atom "?"                            { fn { ctx => @regex.opt($1(ctx)) } }
  ;

atom                                    -> (Context) -> @type.Regex
  : "(" alias ")"                       { $2 }
  | "(" LC_IDENT ":" alias ")"          {
                                          fn (ctx) {
                                            match $2 {
                                              "ascii" => @regex.embed($4(ctx), encoding=Ascii)
                                              "latin1" => @regex.embed($4(ctx), encoding=Latin1)
                                              "utf8" => @regex.embed($4(ctx), encoding=Utf8)
                                              _ => panic()
                                            }
                                          }
                                        }
  | character_class                     { fn { _ctx => @regex.char_class($1) } }
  | LC_IDENT                            { fn { ctx => ctx.named_regexes.get($1).unwrap() } }
  | CHAR                                { fn { _ctx => @regex.char_class(@char_set.singleton($1)) } }
  | STRING                              { fn { _ctx => $1.iter().fold(init=@regex.epsilon, fn(acc, c) { @regex.seq(acc, @regex.char_class(@char_set.singleton(c))) }) } }
  | UNDERSCORE                          { fn { _ctx => @regex.char_class(@char_set.any) } }
  | EOF                                 { fn { _ctx => @regex.eof } }
  ;

character_class                         -> @char_set.T
  : "[" character_class_inner "]"       { $2 }
  | "[" "^" character_class_inner "]"   { $3.negated() }
  ;

character_class_inner                   -> @char_set.T
  : character_class_item character_class_inner 
                                        { $1 + $2 }
  | character_class_item                { $1 }
  ;

character_class_item                    -> @char_set.T
  : CHAR                                { @char_set.singleton($1) }
  | CHAR "-" CHAR                       { @char_set.range($1, $3)}
  ;
